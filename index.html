<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Board</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Theme variables (GitHub-like) */
        :root {
            --bg: #f6f8fa;
            --fg: #24292f;
            --muted: #57606a;
            --border: #d0d7de;
            --lane-bg: #e5e7eb;
            --card-bg: #ffffff;
            --menu-bg: #ffffff;
            --menu-hover: #f3f4f6;
            --accent: #0969da; /* links/buttons */
            /* time tracking stripe color (light theme) - subtle warm tone */
            --track: rgba(250, 204, 21, 0.16);
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.08), 0 4px 6px -2px rgba(0, 0, 0, 0.04);
        }
        .theme-dark :root, .theme-dark {
            color-scheme: dark;
            --bg: #0d1117;
            --fg: #c9d1d9;
            --muted: #8b949e;
            --border: #30363d;
            --lane-bg: #161b22;
            --card-bg: #0d1117;
            --menu-bg: #161b22;
            --menu-hover: #21262d;
            --accent: #58a6ff;
            /* time tracking stripe color (dark theme) - subtle cool tone */
            --track: rgba(88, 166, 255, 0.12);
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.35), 0 4px 6px -2px rgba(0, 0, 0, 0.25);
        }
        /* Use Inter font */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg) !important;
            color: var(--fg) !important;
        }
        /* Custom scrollbar for a cleaner look */
        .kanban-board::-webkit-scrollbar {
            height: 8px;
        }
        .kanban-board::-webkit-scrollbar-track {
            background: var(--lane-bg);
            border-radius: 10px;
        }
        .kanban-board::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .kanban-board::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Style for the card being dragged */
        .card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Hide the delete button by default and show on card hover */
        .card .delete-card-btn {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .card:hover .delete-card-btn {
            visibility: visible;
            opacity: 1;
        }
        /* Styles for the modal */
        .modal-backdrop {
            transition: opacity 0.3s ease;
        }
        /* Styles for time tracking */
        .time-display {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        .time-tracking-active {
            /* Use theme-aware track color for the diagonal stripes. Fall back to a soft yellow if --track is missing. */
            background: linear-gradient(90deg, var(--track, rgba(254,243,199,0.5)), var(--track, rgba(254,243,199,0.5)) 50%, transparent 50%);
            background-size: 20px 20px;
            animation: time-pulse 2s linear infinite;
        }
        @keyframes time-pulse {
            0% { background-position: 0 0; }
            100% { background-position: 20px 0; }
        }
        /* Context menu styles */
        .context-menu {
            position: fixed;
            background: var(--menu-bg);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            box-shadow: var(--shadow);
            z-index: 1000;
            padding: 0.5rem 0;
            min-width: 160px;
        }
        .context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background-color 0.15s ease;
            color: var(--fg);
        }
        .context-menu-item:hover {
            background-color: var(--menu-hover);
        }
        .context-menu-item.disabled {
            color: var(--muted);
            cursor: not-allowed;
        }
        .context-menu-item.disabled:hover {
            background-color: transparent;
        }

        /* GitHub-style surfaces and text overrides */
        .lane {
            background-color: var(--lane-bg) !important;
            border: 1px solid var(--border);
        }
        .lane-title { color: var(--fg) !important; }
        .card {
            background-color: var(--card-bg) !important;
            color: var(--fg) !important;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }
        .time-display { color: var(--muted) !important; }
        .add-card-btn { color: var(--muted) !important; border: 1px dashed transparent; }
        .theme-dark .add-card-btn:hover { background-color: var(--menu-hover) !important; border-color: var(--border); }

        /* Modals */
        .modal-content {
            background-color: var(--card-bg) !important;
            color: var(--fg) !important;
            border: 1px solid var(--border);
        }
        #modal-input {
            background-color: var(--card-bg);
            color: var(--fg);
            border: 1px solid var(--border);
        }
        /* Neutral buttons in modals */
        #modal-cancel-btn, #time-log-close-btn {
            background-color: transparent !important;
            color: var(--fg) !important;
            border: 1px solid var(--border);
        }
        #modal-cancel-btn:hover, #time-log-close-btn:hover {
            background-color: var(--menu-hover) !important;
        }

        /* Inputs */
        select, input, button {
            outline-color: var(--accent);
        }
        #project-picker {
            background-color: var(--card-bg);
            color: var(--fg);
            border-color: var(--border);
        }

        /* Header subtle text */
        label[for="project-picker"] { color: var(--fg) !important; }
        .lane-header .delete-lane-btn { color: var(--muted) !important; }
        .lane-header .delete-lane-btn:hover { color: #f85149 !important; }

        /* Theme toggle button */
        #theme-toggle {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: transparent;
            color: var(--fg);
            border: 1px solid var(--border);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow);
            transition: background-color .15s ease, border-color .15s ease, transform .1s ease;
        }
        #theme-toggle:hover { background-color: var(--menu-hover); }
        #theme-toggle:active { transform: scale(0.98); }
        #theme-toggle .icon { font-size: 1rem; }

    /* Utility override helpers for dark theme (to coexist with Tailwind classes) */
    .theme-dark .text-gray-800, .theme-dark .text-gray-700 { color: var(--fg) !important; }
    .theme-dark .text-gray-600, .theme-dark .text-gray-500, .theme-dark .text-gray-400 { color: var(--muted) !important; }
    .theme-dark .bg-white { background-color: var(--card-bg) !important; }
    .theme-dark .bg-gray-50 { background-color: var(--menu-hover) !important; }
    .theme-dark .bg-gray-100, .theme-dark .bg-gray-200 { background-color: var(--lane-bg) !important; }
    .theme-dark .border-gray-200, .theme-dark .border-gray-300 { border-color: var(--border) !important; }
    </style>
</head>
<body>

    <div class="container mx-auto p-4 md:p-8">
        <div class="flex flex-col md:flex-row justify-center md:justify-between mb-8 gap-4 items-center">
            <div class="flex gap-2 items-center">
                <label for="project-picker" class="font-semibold text-gray-700">Project:</label>
                <select id="project-picker" class="border rounded-md px-2 py-1 bg-white shadow-sm"></select>
                <button id="add-project-btn" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-1 px-3 rounded-lg shadow-md transition-transform transform hover:scale-105">+ Add Project</button>
                <button id="remove-project-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg shadow-md transition-transform transform hover:scale-105">üóëÔ∏è Remove Project</button>
            </div>
            <div class="flex gap-2 mt-4 md:mt-0 items-center">
                <button id="add-lane-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    &#43; Add New Lane
                </button>
                <button id="export-csv-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    üìã Copy CSV to Clipboard
                </button>
                <button id="export-sheet-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    üìä Copy Sheet Format
                </button>
                <button id="theme-toggle" class="ml-2" type="button" aria-label="Toggle dark mode" title="Toggle dark mode">
                    <span class="icon" id="theme-toggle-icon">üåô</span>
                    <span id="theme-toggle-text">Dark</span>
                </button>
            </div>
        </div>

        <!-- Kanban Board Container -->
        <div id="kanban-board" class="kanban-board flex justify-center gap-6 pb-4 overflow-x-auto min-h-[60vh]">
            <!-- Lanes will be dynamically inserted here -->
        </div>
    </div>

    <!-- Modal for input (replaces prompt) -->
    <div id="input-modal" class="modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center hidden">
        <div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 id="modal-title" class="text-xl font-semibold mb-4">Enter a title</h3>
            <input id="modal-input" type="text" class="w-full border-gray-300 rounded-md shadow-sm p-2 mb-4" placeholder="Title...">
            <div class="flex justify-end gap-3">
                <button id="modal-cancel-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="modal-ok-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">OK</button>
            </div>
        </div>
    </div>

    <!-- Modal for confirmation (replaces confirm) -->
    <div id="confirm-modal" class="modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center hidden">
        <div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 id="confirm-modal-title" class="text-xl font-semibold mb-4">Are you sure?</h3>
            <p id="confirm-modal-text" class="text-gray-600 mb-6">Do you really want to delete this item?</p>
            <div class="flex justify-end gap-3">
                <button id="confirm-cancel-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="confirm-ok-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Delete</button>
            </div>
        </div>
    </div>

    <!-- Context menu for time tracking -->
    <div id="context-menu" class="context-menu hidden">
        <div id="start-timer" class="context-menu-item">‚è±Ô∏è Start Timer</div>
        <div id="pause-timer" class="context-menu-item disabled">‚è∏Ô∏è Pause Timer</div>
        <div id="stop-timer" class="context-menu-item disabled">‚èπÔ∏è Stop Timer</div>
        <div id="reset-timer" class="context-menu-item">üîÑ Reset Time</div>
        <div id="view-time-log" class="context-menu-item">üìä View Time Log</div>
    </div>

    <!-- Time log modal -->
    <div id="time-log-modal" class="modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center hidden">
        <div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-xl font-semibold mb-4">Time Log</h3>
            <div id="time-log-content" class="max-h-60 overflow-y-auto mb-4">
                <!-- Time log entries will be populated here -->
            </div>
            <div class="flex justify-end">
                <button id="time-log-close-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Close</button>
            </div>
        </div>
    </div>


    <script>

        document.addEventListener('DOMContentLoaded', () => {
            // --- THEME SETUP ---
            const THEME_KEY = 'kanbanTheme'; // 'light' | 'dark'
            const themeToggleBtn = document.getElementById('theme-toggle');
            const themeToggleIcon = document.getElementById('theme-toggle-icon');
            const themeToggleText = document.getElementById('theme-toggle-text');

            const applyTheme = (theme) => {
                const isDark = theme === 'dark';
                document.documentElement.classList.toggle('theme-dark', isDark);
                // Update toggle visuals
                if (isDark) {
                    themeToggleIcon.textContent = '‚òÄÔ∏è';
                    themeToggleText.textContent = 'Light';
                    themeToggleBtn.setAttribute('aria-label', 'Switch to light mode');
                    themeToggleBtn.title = 'Switch to light mode';
                } else {
                    themeToggleIcon.textContent = 'üåô';
                    themeToggleText.textContent = 'Dark';
                    themeToggleBtn.setAttribute('aria-label', 'Switch to dark mode');
                    themeToggleBtn.title = 'Switch to dark mode';
                }
                // Optional: set theme-color for mobile address bar
                const themeColor = document.querySelector('meta[name="theme-color"]') || (function(){
                    const m = document.createElement('meta'); m.name = 'theme-color'; document.head.appendChild(m); return m;})();
                themeColor.setAttribute('content', getComputedStyle(document.body).backgroundColor);
            };

            const getPreferredTheme = () => {
                const saved = localStorage.getItem(THEME_KEY);
                if (saved === 'light' || saved === 'dark') return saved;
                return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            };

            let currentTheme = getPreferredTheme();
            applyTheme(currentTheme);
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', () => {
                    currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    localStorage.setItem(THEME_KEY, currentTheme);
                    applyTheme(currentTheme);
                });
            }

            const kanbanBoard = document.getElementById('kanban-board');
            const addLaneBtn = document.getElementById('add-lane-btn');
            const exportCsvBtn = document.getElementById('export-csv-btn');
            const exportSheetBtn = document.getElementById('export-sheet-btn');
            const projectPicker = document.getElementById('project-picker');
            const addProjectBtn = document.getElementById('add-project-btn');
            const removeProjectBtn = document.getElementById('remove-project-btn');

            // Modal elements
            const inputModal = document.getElementById('input-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalInput = document.getElementById('modal-input');
            const modalOkBtn = document.getElementById('modal-ok-btn');
            const modalCancelBtn = document.getElementById('modal-cancel-btn');

            const confirmModal = document.getElementById('confirm-modal');
            const confirmModalText = document.getElementById('confirm-modal-text');
            const confirmOkBtn = document.getElementById('confirm-ok-btn');
            const confirmCancelBtn = document.getElementById('confirm-cancel-btn');

            // Time tracking elements
            const contextMenu = document.getElementById('context-menu');
            const timeLogModal = document.getElementById('time-log-modal');
            const timeLogContent = document.getElementById('time-log-content');
            const timeLogCloseBtn = document.getElementById('time-log-close-btn');

            let draggedCard = null;
            let onOk; // Callback for modal confirmation
            let currentTrackingCard = null;
            let trackingInterval = null;
            let contextMenuCard = null;

            // --- MULTI-PROJECT SUPPORT ---
            // Structure: { projectName: { lanes: [...], timeData: {...} } }
            let allProjects = {};
            let currentProject = null;
            let cardTimeData = {};

            // Load all projects from localStorage
            const loadAllProjects = () => {
                const raw = localStorage.getItem('kanbanProjects');
                if (!raw) return {};
                try {
                    return JSON.parse(raw);
                } catch {
                    return {};
                }
            };

            // Save all projects to localStorage
            const saveAllProjects = () => {
                localStorage.setItem('kanbanProjects', JSON.stringify(allProjects));
            };

            // Populate project picker
            const updateProjectPicker = () => {
                projectPicker.innerHTML = '';
                Object.keys(allProjects).forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    projectPicker.appendChild(opt);
                });
                if (currentProject && allProjects[currentProject]) {
                    projectPicker.value = currentProject;
                }
            };

            // Switch project
            const switchProject = (name) => {
                if (!allProjects[name]) return;
                currentProject = name;
                cardTimeData = allProjects[name].timeData || {};
                loadState();
                updateProjectPicker();
            };

            // Add new project

            addProjectBtn.addEventListener('click', () => {
                showInputModal('Enter new project name:', (projectName) => {
                    if (!allProjects[projectName]) {
                        // Add default 3 lanes and example cards
                        allProjects[projectName] = {
                            lanes: [
                                { title: 'To Do', cards: [] },
                                { title: 'In Progress', cards: [] },
                                { title: 'Done', cards: [] }
                            ],
                            timeData: {}
                        };
                        saveAllProjects();
                        currentProject = projectName;
                        cardTimeData = {};
                        updateProjectPicker();
                        loadState();
                        saveState(); // Save after board is rendered
                    } else {
                        alert('Project already exists!');
                    }
                });
            });

            // Remove current project
            removeProjectBtn.addEventListener('click', () => {
                if (!currentProject) return;
                // If only one project remains, ask for extra confirmation
                const projectCount = Object.keys(allProjects).length;
                const confirmText = projectCount === 1
                    ? `Project "${currentProject}" is the only project. Delete it and reset the board?`
                    : `Delete project "${currentProject}" and all its lanes & cards?`;
                showConfirmModal(confirmText, () => {
                    // Stop any active tracking
                    if (currentTrackingCard) {
                        stopTracking(currentTrackingCard);
                    }
                    delete allProjects[currentProject];
                    saveAllProjects();
                    const remaining = Object.keys(allProjects);
                    if (remaining.length) {
                        switchProject(remaining[0]);
                    } else {
                        // Create a fresh empty default project structure or leave blank board
                        kanbanBoard.innerHTML = '';
                        cardTimeData = {};
                        currentProject = null;
                        updateProjectPicker();
                        // Optionally auto-create a new default project for convenience
                        allProjects['Default Project'] = { lanes: [], timeData: {} };
                        currentProject = 'Default Project';
                        saveAllProjects();
                        updateProjectPicker();
                        loadState();
                    }
                });
            });

            // Project picker change
            projectPicker.addEventListener('change', (e) => {
                switchProject(e.target.value);
            });

            /**
             * Debounce function to limit the rate at which a function gets called.
             * @param {Function} func The function to debounce.
             * @param {number} delay The delay in milliseconds.
             * @returns {Function} The debounced function.
             */
            const debounce = (func, delay) => {
                let timeoutId;
                return (...args) => {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            };


            // Save current project state
            const saveState = () => {
                if (!currentProject) return;
                const lanes = [];
                document.querySelectorAll('.lane').forEach(laneEl => {
                    const laneTitle = laneEl.querySelector('.lane-title').textContent;
                    const cards = [];
                    laneEl.querySelectorAll('.card').forEach(cardEl => {
                        const cardId = cardEl.dataset.cardId;
                        const cardText = cardEl.querySelector('span').textContent;
                        cards.push({ 
                            id: cardId,
                            text: cardText 
                        });
                    });
                    lanes.push({ title: laneTitle, cards: cards });
                });
                allProjects[currentProject] = {
                    lanes: lanes,
                    timeData: cardTimeData
                };
                saveAllProjects();
                // Also keep legacy for backward compatibility
                localStorage.setItem('kanbanBoardState', JSON.stringify({lanes, timeData: cardTimeData}));
                console.log('Project state saved.');
            };

            const debouncedSave = debounce(saveState, 500);

            /**
             * Time tracking utility functions
             */
            const generateCardId = () => {
                return 'card_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            };

            const formatTime = (milliseconds) => {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m ${seconds}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${seconds}s`;
                } else {
                    return `${seconds}s`;
                }
            };

            const initializeCardTimeData = (cardId) => {
                if (!cardTimeData[cardId]) {
                    cardTimeData[cardId] = {
                        totalTime: 0,
                        isTracking: false,
                        startTime: null,
                        sessions: []
                    };
                }
            };

            const startTracking = (cardId) => {
                // Stop any currently tracking card
                if (currentTrackingCard && currentTrackingCard !== cardId) {
                    stopTracking(currentTrackingCard);
                }

                initializeCardTimeData(cardId);
                const timeData = cardTimeData[cardId];
                
                if (!timeData.isTracking) {
                    timeData.isTracking = true;
                    timeData.startTime = Date.now();
                    currentTrackingCard = cardId;
                    
                    const cardEl = document.querySelector(`[data-card-id="${cardId}"]`);
                    if (cardEl) {
                        cardEl.classList.add('time-tracking-active');
                    }
                    
                    // Start interval to update display
                    if (trackingInterval) clearInterval(trackingInterval);
                    trackingInterval = setInterval(() => updateTrackingDisplay(), 1000);
                    
                    updateTrackingDisplay();
                    debouncedSave();
                }
            };

            const pauseTracking = (cardId) => {
                initializeCardTimeData(cardId);
                const timeData = cardTimeData[cardId];
                
                if (timeData.isTracking && timeData.startTime) {
                    const sessionDuration = Date.now() - timeData.startTime;
                    timeData.totalTime += sessionDuration;
                    timeData.sessions.push({
                        start: timeData.startTime,
                        end: Date.now(),
                        duration: sessionDuration
                    });
                    
                    timeData.isTracking = false;
                    timeData.startTime = null;
                    currentTrackingCard = null;
                    
                    const cardEl = document.querySelector(`[data-card-id="${cardId}"]`);
                    if (cardEl) {
                        cardEl.classList.remove('time-tracking-active');
                        updateCardTimeDisplay(cardEl, cardId);
                    }
                    
                    if (trackingInterval) {
                        clearInterval(trackingInterval);
                        trackingInterval = null;
                    }
                    
                    debouncedSave();
                }
            };

            const stopTracking = (cardId) => {
                pauseTracking(cardId); // Same as pause for now
            };

            const resetTime = (cardId) => {
                if (cardTimeData[cardId]) {
                    if (cardTimeData[cardId].isTracking) {
                        stopTracking(cardId);
                    }
                    
                    cardTimeData[cardId] = {
                        totalTime: 0,
                        isTracking: false,
                        startTime: null,
                        sessions: []
                    };
                    
                    const cardEl = document.querySelector(`[data-card-id="${cardId}"]`);
                    if (cardEl) {
                        updateCardTimeDisplay(cardEl, cardId);
                    }
                    
                    debouncedSave();
                }
            };

            const updateTrackingDisplay = () => {
                if (currentTrackingCard) {
                    const cardEl = document.querySelector(`[data-card-id="${currentTrackingCard}"]`);
                    if (cardEl) {
                        updateCardTimeDisplay(cardEl, currentTrackingCard);
                    }
                }
            };

            const updateCardTimeDisplay = (cardEl, cardId) => {
                initializeCardTimeData(cardId);
                const timeData = cardTimeData[cardId];
                
                let currentTime = timeData.totalTime;
                if (timeData.isTracking && timeData.startTime) {
                    currentTime += Date.now() - timeData.startTime;
                }
                
                let timeDisplay = cardEl.querySelector('.time-display');
                if (!timeDisplay) {
                    timeDisplay = document.createElement('div');
                    timeDisplay.className = 'time-display';
                    cardEl.appendChild(timeDisplay);
                }
                
                if (currentTime > 0) {
                    timeDisplay.textContent = `‚è±Ô∏è ${formatTime(currentTime)}`;
                    timeDisplay.style.display = 'block';
                } else {
                    timeDisplay.style.display = 'none';
                }
            };

            const showTimeLog = (cardId) => {
                initializeCardTimeData(cardId);
                const timeData = cardTimeData[cardId];
                
                let logHtml = '';
                if (timeData.sessions.length === 0) {
                    logHtml = '<p class="text-gray-500 text-center">No time sessions recorded yet.</p>';
                } else {
                    logHtml = '<div class="space-y-2">';
                    timeData.sessions.forEach((session, index) => {
                        const startDate = new Date(session.start);
                        const endDate = new Date(session.end);
                        logHtml += `
                            <div class="bg-gray-50 p-3 rounded-md">
                                <div class="font-semibold">Session ${index + 1}</div>
                                <div class="text-sm text-gray-600">
                                    ${startDate.toLocaleDateString()} ${startDate.toLocaleTimeString()} - 
                                    ${endDate.toLocaleTimeString()}
                                </div>
                                <div class="text-sm font-medium">Duration: ${formatTime(session.duration)}</div>
                            </div>
                        `;
                    });
                    logHtml += `
                        </div>
                        <div class="mt-4 pt-4 border-t border-gray-200">
                            <div class="font-semibold">Total Time: ${formatTime(timeData.totalTime)}</div>
                        </div>
                    `;
                }
                
                timeLogContent.innerHTML = logHtml;
                timeLogModal.classList.remove('hidden');
            };

            const restoreTrackingState = () => {
                // Find any card that was being tracked before reload
                for (const cardId in cardTimeData) {
                    const timeData = cardTimeData[cardId];
                    if (timeData.isTracking) {
                        const cardEl = document.querySelector(`[data-card-id="${cardId}"]`);
                        if (cardEl) {
                            // Restore visual state
                            cardEl.classList.add('time-tracking-active');
                            currentTrackingCard = cardId;
                            
                            // Start the tracking interval
                            if (trackingInterval) clearInterval(trackingInterval);
                            trackingInterval = setInterval(() => updateTrackingDisplay(), 1000);
                            
                            // Update display immediately
                            updateTrackingDisplay();
                            break; // Only one card should be tracking at a time
                        }
                    }
                }
            };

            /**
             * Copies the current board state to clipboard as CSV
             */
            const exportToCSV = async () => {
                const csvRows = [];
                
                // Add header row
                csvRows.push(['Lane', 'Card', 'Total Time', 'Sessions']);
                
                // Collect data from all lanes
                document.querySelectorAll('.lane').forEach(laneEl => {
                    const laneTitle = laneEl.querySelector('.lane-title').textContent.trim();
                    const cards = laneEl.querySelectorAll('.card');
                    
                    if (cards.length === 0) {
                        // Add lane even if it has no cards
                        csvRows.push([laneTitle, '', '', '']);
                    } else {
                        cards.forEach(cardEl => {
                            const cardText = cardEl.querySelector('span').textContent.trim();
                            const cardId = cardEl.dataset.cardId;
                            
                            initializeCardTimeData(cardId);
                            const timeData = cardTimeData[cardId];
                            
                            let totalTime = timeData.totalTime;
                            if (timeData.isTracking && timeData.startTime) {
                                totalTime += Date.now() - timeData.startTime;
                            }
                            
                            const formattedTime = totalTime > 0 ? formatTime(totalTime) : '';
                            const sessionCount = timeData.sessions.length;
                            
                            csvRows.push([laneTitle, cardText, formattedTime, sessionCount]);
                        });
                    }
                });
                
                // Convert to CSV format
                const csvContent = csvRows.map(row => 
                    row.map(field => `"${field.toString().replace(/"/g, '""')}"`)
                       .join(',')
                ).join('\n');
                
                // Copy to clipboard
                try {
                    await navigator.clipboard.writeText(csvContent);
                    
                    // Show temporary success feedback
                    const button = document.getElementById('export-csv-btn');
                    const originalText = button.innerHTML;
                    button.innerHTML = '‚úÖ Copied to Clipboard!';
                    button.classList.remove('bg-green-600', 'hover:bg-green-700');
                    button.classList.add('bg-green-800');
                    
                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.classList.remove('bg-green-800');
                        button.classList.add('bg-green-600', 'hover:bg-green-700');
                    }, 2000);
                    
                    console.log('Board CSV data copied to clipboard successfully.');
                } catch (err) {
                    console.error('Failed to copy to clipboard:', err);
                    // Fallback: show the CSV in a modal or alert
                    alert('Failed to copy to clipboard. Here is the CSV data:\n\n' + csvContent);
                }
            };

            /**
             * Copies the current board state to clipboard in structured sheet format
             */
            const exportToSheetFormat = async () => {
                const lanes = [];
                const maxCards = Math.max(...Array.from(document.querySelectorAll('.lane')).map(lane => 
                    lane.querySelectorAll('.card').length
                ));
                
                // Collect data from all lanes
                document.querySelectorAll('.lane').forEach(laneEl => {
                    const laneTitle = laneEl.querySelector('.lane-title').textContent.trim();
                    const cards = [];
                    laneEl.querySelectorAll('.card').forEach(cardEl => {
                        const cardText = cardEl.querySelector('span').textContent.trim();
                        const cardId = cardEl.dataset.cardId;
                        
                        initializeCardTimeData(cardId);
                        const timeData = cardTimeData[cardId];
                        
                        let totalTime = timeData.totalTime;
                        if (timeData.isTracking && timeData.startTime) {
                            totalTime += Date.now() - timeData.startTime;
                        }
                        
                        const formattedTime = totalTime > 0 ? formatTime(totalTime) : '';
                        cards.push(`${cardText}${formattedTime ? ' (' + formattedTime + ')' : ''}`);
                    });
                    lanes.push({ title: laneTitle, cards: cards });
                });
                
                // Build the structured format
                const sheetRows = [];
                
                // Add lane titles as headers
                const headers = lanes.map(lane => lane.title);
                sheetRows.push(headers);
                
                // Add cards row by row
                for (let i = 0; i < maxCards; i++) {
                    const row = lanes.map(lane => lane.cards[i] || '');
                    sheetRows.push(row);
                }
                
                // Convert to tab-separated format (better for spreadsheets)
                const sheetContent = sheetRows.map(row => 
                    row.map(field => field.replace(/\t/g, ' ').replace(/\n/g, ' '))
                       .join('\t')
                ).join('\n');
                
                // Copy to clipboard
                try {
                    await navigator.clipboard.writeText(sheetContent);
                    
                    // Show temporary success feedback
                    const button = document.getElementById('export-sheet-btn');
                    const originalText = button.innerHTML;
                    button.innerHTML = '‚úÖ Copied Sheet Format!';
                    button.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                    button.classList.add('bg-purple-800');
                    
                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.classList.remove('bg-purple-800');
                        button.classList.add('bg-purple-600', 'hover:bg-purple-700');
                    }, 2000);
                    
                    console.log('Board sheet format data copied to clipboard successfully.');
                } catch (err) {
                    console.error('Failed to copy to clipboard:', err);
                    // Fallback: show the data in a modal or alert
                    alert('Failed to copy to clipboard. Here is the sheet format data:\n\n' + sheetContent);
                }
            };


            // Load current project state
            const loadState = () => {
                if (!currentProject || !allProjects[currentProject]) return false;
                const state = allProjects[currentProject];
                if (!state || !state.lanes) return false;
                kanbanBoard.innerHTML = '';
                cardTimeData = state.timeData || {};
                state.lanes.forEach(laneData => {
                    addLane(laneData.title, false); // Add lane without saving
                    const newLane = kanbanBoard.lastElementChild;
                    if (newLane) {
                        laneData.cards.forEach(cardData => {
                            if (typeof cardData === 'string') {
                                addCard(newLane, cardData, false);
                            } else {
                                addCard(newLane, cardData.text, false, cardData.id);
                            }
                        });
                    }
                });
                // Update existing cards without IDs and restore tracking state
                document.querySelectorAll('.card:not([data-card-id])').forEach(card => {
                    card.dataset.cardId = generateCardId();
                    updateCardTimeDisplay(card, card.dataset.cardId);
                });
                restoreTrackingState();
                return true;
            };

            const showInputModal = (title, callback) => {
                modalTitle.textContent = title;
                modalInput.value = '';
                inputModal.classList.remove('hidden');
                modalInput.focus();
                onOk = () => {
                    const value = modalInput.value.trim();
                    if (value) {
                        callback(value);
                        hideInputModal();
                    }
                };
            };

            const hideInputModal = () => inputModal.classList.add('hidden');
            modalOkBtn.addEventListener('click', () => onOk());
            modalCancelBtn.addEventListener('click', hideInputModal);
            modalInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') onOk();
                if (e.key === 'Escape') hideInputModal();
            });

            const showConfirmModal = (text, callback) => {
                confirmModalText.textContent = text;
                confirmModal.classList.remove('hidden');
                onOk = () => {
                    callback();
                    hideConfirmModal();
                };
            };

            const hideConfirmModal = () => confirmModal.classList.add('hidden');
            confirmOkBtn.addEventListener('click', () => onOk());
            confirmCancelBtn.addEventListener('click', hideConfirmModal);

            // Context menu functions
            const showContextMenu = (x, y, cardId) => {
                initializeCardTimeData(cardId);
                const timeData = cardTimeData[cardId];
                
                // Update menu item states
                const startTimer = document.getElementById('start-timer');
                const pauseTimer = document.getElementById('pause-timer');
                const stopTimer = document.getElementById('stop-timer');
                const resetTimer = document.getElementById('reset-timer');
                
                if (timeData.isTracking) {
                    startTimer.classList.add('disabled');
                    pauseTimer.classList.remove('disabled');
                    stopTimer.classList.remove('disabled');
                } else {
                    startTimer.classList.remove('disabled');
                    pauseTimer.classList.add('disabled');
                    stopTimer.classList.add('disabled');
                }
                
                // Position and show context menu
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.classList.remove('hidden');
                
                // Adjust position if menu goes off screen
                const rect = contextMenu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    contextMenu.style.left = (x - rect.width) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    contextMenu.style.top = (y - rect.height) + 'px';
                }
            };

            const hideContextMenu = () => {
                contextMenu.classList.add('hidden');
                contextMenuCard = null;
            };

            // Context menu event listeners
            document.getElementById('start-timer').addEventListener('click', () => {
                if (contextMenuCard && !document.getElementById('start-timer').classList.contains('disabled')) {
                    startTracking(contextMenuCard);
                }
                hideContextMenu();
            });

            document.getElementById('pause-timer').addEventListener('click', () => {
                if (contextMenuCard && !document.getElementById('pause-timer').classList.contains('disabled')) {
                    pauseTracking(contextMenuCard);
                }
                hideContextMenu();
            });

            document.getElementById('stop-timer').addEventListener('click', () => {
                if (contextMenuCard && !document.getElementById('stop-timer').classList.contains('disabled')) {
                    stopTracking(contextMenuCard);
                }
                hideContextMenu();
            });

            document.getElementById('reset-timer').addEventListener('click', () => {
                if (contextMenuCard) {
                    showConfirmModal('Are you sure you want to reset the time for this card?', () => {
                        resetTime(contextMenuCard);
                    });
                }
                hideContextMenu();
            });

            document.getElementById('view-time-log').addEventListener('click', () => {
                if (contextMenuCard) {
                    showTimeLog(contextMenuCard);
                }
                hideContextMenu();
            });

            // Time log modal event listeners
            timeLogCloseBtn.addEventListener('click', () => {
                timeLogModal.classList.add('hidden');
            });

            // Hide context menu when clicking elsewhere
            document.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target) && !e.target.closest('.card')) {
                    hideContextMenu();
                }
            });

            const addLane = (title = 'New Lane', shouldSave = true) => {
                const lane = document.createElement('div');
                lane.className = 'lane bg-gray-200 rounded-lg p-4 w-80 flex-shrink-0 shadow-sm';
                lane.innerHTML = `
                    <div class="lane-header flex justify-between items-center mb-2">
                        <h2 class="lane-title text-lg font-semibold text-gray-700" contenteditable="true">${title}</h2>
                        <div class="flex items-center gap-2">
                            <button class="add-card-btn text-left text-gray-600 hover:bg-gray-300 px-3 py-2 rounded-md transition-colors duration-200 border border-transparent">&#43; Add Card</button>
                            <button class="delete-lane-btn text-gray-500 hover:text-red-600 text-xl font-bold" title="Delete Lane">&times;</button>
                        </div>
                    </div>
                    <div class="cards min-h-[100px] max-h-[60vh] overflow-y-auto flex flex-col gap-3"></div>
                `;
                kanbanBoard.appendChild(lane);
                setupLaneEventListeners(lane);
                if (shouldSave) debouncedSave();
            };

            const addCard = (lane, text = 'New Card', shouldSave = true, cardId = null) => {
                const cardsContainer = lane.querySelector('.cards');
                const card = document.createElement('div');
                const id = cardId || generateCardId();
                
                card.className = 'card bg-white rounded-md p-3 shadow-md cursor-grab active:cursor-grabbing';
                card.draggable = true;
                card.dataset.cardId = id;
                card.innerHTML = `
                    <div class="flex justify-between items-start">
                        <span contenteditable="true" class="flex-1">${text}</span>
                        <button class="delete-card-btn text-gray-400 hover:text-red-500 ml-2" title="Delete Card">üóëÔ∏è</button>
                    </div>
                `;
                cardsContainer.appendChild(card);
                setupCardEventListeners(card);
                updateCardTimeDisplay(card, id);
                if (shouldSave) debouncedSave();
            };

            const setupLaneEventListeners = (lane) => {
                const titleEl = lane.querySelector('.lane-title');
                titleEl.addEventListener('blur', debouncedSave);

                lane.querySelector('.delete-lane-btn').addEventListener('click', () => {
                    showConfirmModal('Are you sure you want to delete this lane and all its cards?', () => {
                        lane.remove();
                        debouncedSave();
                    });
                });

                lane.querySelector('.add-card-btn').addEventListener('click', () => {
                    showInputModal('Enter card text:', (cardText) => {
                        addCard(lane, cardText);
                    });
                });

                const cardsContainer = lane.querySelector('.cards');
                cardsContainer.addEventListener('dragover', (e) => e.preventDefault());
                cardsContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedCard) {
                        cardsContainer.appendChild(draggedCard);
                        debouncedSave();
                    }
                });
            };

            const setupCardEventListeners = (card) => {
                const cardTextEl = card.querySelector('span');
                const cardId = card.dataset.cardId;
                
                cardTextEl.addEventListener('blur', debouncedSave);

                card.querySelector('.delete-card-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    showConfirmModal('Are you sure you want to delete this card?', () => {
                        // Stop tracking if this card is being tracked
                        if (currentTrackingCard === cardId) {
                            stopTracking(cardId);
                        }
                        // Remove time data
                        delete cardTimeData[cardId];
                        card.remove();
                        debouncedSave();
                    });
                });

                // Context menu for time tracking
                card.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    contextMenuCard = cardId;
                    showContextMenu(e.clientX, e.clientY, cardId);
                });

                card.addEventListener('dragstart', () => {
                    draggedCard = card;
                    setTimeout(() => card.classList.add('dragging'), 0);
                });

                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                    draggedCard = null;
                });
            };

            // --- INITIALIZATION ---

            addLaneBtn.addEventListener('click', () => {
                showInputModal('Enter new lane title:', (laneTitle) => {
                    addLane(laneTitle);
                });
            });

            exportCsvBtn.addEventListener('click', exportToCSV);

            exportSheetBtn.addEventListener('click', exportToSheetFormat);


            // --- INITIALIZATION ---
            // Load all projects
            allProjects = loadAllProjects();
            let firstProject = Object.keys(allProjects)[0];
            if (!firstProject) {
                // If no projects, create a default one
                allProjects['Default Project'] = {
                    lanes: [
                        { title: 'To Do', cards: [ {text: 'Complete project proposal üìë', id: generateCardId()}, {text: 'Schedule team meeting üìÖ', id: generateCardId()} ] },
                        { title: 'In Progress', cards: [ {text: 'Develop the main feature üë®‚Äçüíª', id: generateCardId()} ] },
                        { title: 'Done', cards: [ {text: 'Deploy to production ‚ú®', id: generateCardId()} ] }
                    ],
                    timeData: {}
                };
                saveAllProjects();
                firstProject = 'Default Project';
            }
            currentProject = firstProject;
            updateProjectPicker();
            loadState();
        });
    </script>

</body>
</html>
